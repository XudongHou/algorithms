package com.hxd.sort.base;

/**
 * 候旭东 20161216希尔排序
 * 基于插入排序的快速的排序算法.对于大规模排序数组插入排序很慢,因为它只会交换相邻的元素,因此元素只能一点点的从数组
 * 的一端移动到另一端.
 * 希尔排序为了加快速度简单地改进了插入排序,交换不相邻的元素以对数组的局部进行排序,并最终用插入排序将局部有序的数组
 * 排序
 * 希尔排序的思想是是数组中任意间隔为h的元素都是有序的.这样的数组被称为h有序数组.换句话说,一个h有序数组就是h个互
 * 相独立的有序数组编制在一起组成的一个数组,在进行排序时,如果h很大,我们就能将元素移动到很远的地方,为实现更小的h有
 * 序创造方便,用这种方式,对于任意以1结尾的h序列,我们都能将数组排序.
 * */
@SuppressWarnings("rawtypes")
public class Shell extends Example {
     /**
	 * 实现了序列1/2(3^k-1),从N/3开始递减至1.我们把这个序列成为递增序列,另一种方法是将递增序列存储在一个数
	 * 组中.
	 * 实现希尔排序的一种方法是对于每个h,用插入排序将h个子数组独立地排序.但是子数组是相互独立的,一个更简洁的方法
	 * 是h-子数组中将每个元素交换到比它大的元素之前去(将把比它大的元素向右移动一格).只需要在插入排序的代码中将移
	 * 动的元素的距离由1改成h即可.此时的希尔排序的实现就转化为了一个类似于插入排序但使用不同增量的过程
	 * 希尔排序更高效的原因是它权衡了子数组的规模和有序性.排序之初,各个子数组都很短,排序之后子数组都是部分有序的,
	 * 这两种情况都很适合插入排序.子数组部分有序的程度取决于递增序列的选择,透彻理解希尔排序的性能至今仍是一个挑战.
	 * 希尔排序也可以用于大型数组
	 * 希尔排序的运作运行时间打不到平方级别
	 * 希尔排序因为对于中等大小的数组它的运行时间是可以接受的.对于一个排序问题而又没有系统排序函数可用,可以先用希
	 * 尔排序
	 * */
	public static void sort(Comparable[] a){
		int N=a.length;
		int h=1;
		/**
		 * 使用递增序列1,4,13,40,121,364..的希尔排序所需的比较次数不会超过N的若干倍乘以递增序列的长度`
		 * */
		while (h<N/3)
			h=3*h+1;	//1,4,13,40,121,364,1093
		while(h>=1){
			for (int i = 0; i < N; i++) {
				for (int j = i; j >=h && less(a[j], a[j-h]); j-=h) 			
					exch(a, j, j-h);
			}
			h=h/3;
		}
	}
	
	public static void main(String[] args) {
		String[] a = new String[]{"bed","bug","dad","yes","zoo","now","for"
				,"tip","ilk","dim","tag","jot","sob","nob","sky","hut","men","egg","few","jay","owl",
				"joy","rap","gig","wee","was","wad","fee","tap","tar","dug","jam","all","bad","yet"};
		sort(a);
		assert isSorted(a);
		show(a);
	}
}